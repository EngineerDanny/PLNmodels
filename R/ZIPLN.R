#' Zero Inflated Poisson lognormal model
#'
#' Fit the multivariate Zero Inflated Poisson lognormal model with a variational algorithm. Use the (g)lm syntax for model specification (covariates, offsets, subset).
#'
#' @inheritParams PLN
#' @param control a list-like structure for controlling the optimization, with default generated by [ZIPLN_param()]. See the associated documentation
#' for details.
#' @param zi a character describing the model for zero inflation in "single" (one global parameter, the default), "col" (one parameter per variable)
#'  and "row" (one parameter per individuals). If covariates are specified in the formula RHS, after bar pipe like "~ PLN effect | ZI effect", `zi`
#'  is ignored and the covariates extracted by model matrix will be used to account for the ZI effect.
#'
#' @return an R6 object with class [`ZIPLNfit`]
#'
#' @rdname ZIPLN
#' @include ZIPLNfit-class.R
#' @examples
#' data(scRNA)
#' # data subsample: only 100 random cell and the 50 most varying transcript
#' scRNA        <- scRNA[sample.int(nrow(scRNA), 100), ]
#' scRNA$counts <- scRNA$counts[, 1:50]
#' myPLN_full   <- ZIPLN(counts ~ 1 + cell_line + offset(log(total_counts)), data = scRNA)
#' myPLN_sparse <- ZIPLN(counts ~ 1 + offset(log(total_counts)), rho = .5, data = scRNA)
#' myPLN_full$criteria    # better BIC with sparse version
#' myPLN_sparse$criteria
#' @seealso The class [`ZIPLNfit`]
#' @importFrom stats model.frame model.matrix model.response model.offset terms as.formula
#' @export
ZIPLN <- function(formula, data, subset, zi = c("single", "row", "col"), control = ZIPLN_param()) {

  ## extract the data matrices and weights
  args <- extract_model_zi(match.call(expand.dots = FALSE), parent.frame())

  ## define default control parameters for optim and eventually overwrite them by user-defined parameters
  control$lambda  <- 0
  control$rho     <- 0
  control$ziparam <- ifelse((args$zicovar), "covar", match.arg(zi))
  control$penalize_intercept <- FALSE
  if (control$rho > 0) control$covariance <- "sparse"

  ## handling intercept term for penalized regression
  if (attr(terms(as.formula(args$formula)), "intercept") > 0 & !control$penalize_intercept)
    control$ind_intercept <- match("(Intercept)", colnames(args$X))

  ## initialization
  if (control$trace > 0) cat("\n Initialization...")
  myPLN <- switch(control$covariance,
                  "diagonal"  = ZIPLNfit_diagonal$new(args$Y , list(PLN = args$X, ZI = args$X0), args$O, args$w, args$formula, control),
                  "spherical" = ZIPLNfit_spherical$new(args$Y, list(PLN = args$X, ZI = args$X0), args$O, args$w, args$formula, control),
                  "fixed"     = ZIPLNfit_fixedcov$new(args$Y , list(PLN = args$X, ZI = args$X0), args$O, args$w, args$formula, control),
                  ZIPLNfit$new(args$Y, list(PLN = args$X, ZI = args$X0), args$O, args$w, args$formula, control)) # default: full covariance

  ## optimization
  if (control$trace > 0) cat("\n Adjusting a ZI-PLN model with",
                  control$covariance,"covariance model and",
                  control$ziparam, "specific parameter(s) in Zero inflation component.")
  myPLN$optimize(args$Y, list(PLN = args$X, ZI = args$X0), args$O, args$w, control$config_optim)

  if (control$trace > 0) cat("\n DONE!\n")
  myPLN
}

## -----------------------------------------------------------------
##  Series of setter to default parameters for user's main functions

available_algorithms <- c("MMA", "CCSAQ", "LBFGS", "VAR1", "VAR2", "TNEWTON", "TNEWTON_PRECOND", "TNEWTON_PRECOND_RESTART")

#' Control of a PLN fit
#'
#' Helper to define list of parameters to control the PLN fit. All arguments have defaults.
#'
#' @inheritParams PLN_param
#' @return list of parameters configuring the fit.
#'
#' @inherit PLN_param details
#' @details See [PLN_param()] for a full description of the generic optimization parameters. ZIPLN_param() also has two additional parameters controlling the optimization due
#' the inner-outer loop structure of the optimizer:
#' * "ftol_out" outer solver stops when an optimization step changes the objective function by less than xtol multiplied by the absolute value of the parameter. Default is 1e-8
#' * "maxit_out" outer solver stops when the number of iteration exceeds maxit_out. Default is 100
#'
#' @export
ZIPLN_param <- function(
    backend       = c("nlopt"),
    trace         = 1,
    covariance    = c("full", "diagonal", "spherical", "fixed"),
    Omega         = NULL,
    config_post   = list(),
    config_optim  = list(),
    inception     = NULL     # pretrained ZIPLNfit used as initialization
) {

  covariance <- match.arg(covariance)
  if (covariance == "fixed") stopifnot(inherits(Omega, "matrix") | inherits(Omega, "Matrix"))
  if (!is.null(inception)) stopifnot(isZIPLNfit(inception))

  ## post-treatment config
  config_pst <- config_post_default_PLN
  config_pst[names(config_post)] <- config_post
  config_pst$trace <- trace

  ## optimization config
  stopifnot(backend %in% c("nlopt"))
  stopifnot(config_optim$algorithm %in% available_algorithms_nlopt)
  config_opt <- config_default_nlopt
  config_opt$trace <- trace
  config_opt$ftol_out  <- 1e-6
  config_opt$maxit_out <- 100
  config_opt[names(config_optim)] <- config_optim

  structure(list(
    backend       = backend   ,
    trace         = trace     ,
    covariance    = covariance,
    Omega         = Omega     ,
    config_post   = config_pst,
    config_optim  = config_opt,
    inception     = inception), class = "PLNmodels_param")

}
